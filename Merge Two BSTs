// Approach #1
void inorder(TreeNode<int> *root,vector<int> &in){
    if(root==NULL)
        return;
    inorder(root->left,in);
    in.push_back(root->data);
    inorder(root->right,in);
}
vector<int> mergeArrays(vector<int> &a,vector<int> &b){
    vector<int> ans(a.size()+b.size());
    int i=0,j=0,k=0;
    while(  i<a.size() && j<b.size() ){
        if(a[i]<b[j]){
           ans[k++]=a[i];
           i++;
       }
        else{
              ans[k++]=b[j];
              j++;
        }
    }
    while(i<a.size()){
                ans[k++]=a[i];
                 i++;
    }
    while(j < b.size()){
        ans[k++]=b[j];
         j++;
    }
    return ans;
}
TreeNode<int> *inorderToBST(vector<int> &in,int s,int e){
    if(s>e)
        return NULL;
    int mid=(s+e)/2;
    TreeNode<int> *root=new TreeNode<int>(in[mid]);
    root->left= inorderToBST(in,s,mid-1);
    root->right= inorderToBST(in,mid+1,e);
    return root;
}
TreeNode<int> *mergeBST(TreeNode<int> *root1, TreeNode<int> *root2){
// 1. store inorder traversal into vector

    vector<int> bst1,bst2;
    inorder(root1,bst1);
    inorder(root2,bst2);
    
//2. merge these sorted vector
    vector<int> merged= mergeArrays(bst1,bst2);
 //3. convert inorder into BST
    int s=0,e=merged.size()-1;
    return inorderToBST(merged,s,e);
}
// Approach #2
